<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Ai-project by nickdowse</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>COSC343 Assignment 1 - Robots</h1>
        <p>NXC Code for my recent robotics assignment.</p>

        <p class="view"><a href="https://github.com/nickdowse/ai-project">View the Project on GitHub <small>nickdowse/ai-project</small></a></p>


        <ul>
          <li><a href="https://github.com/nickdowse/ai-project">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h3>
<a name="1-the-challenge" class="anchor" href="#1-the-challenge"><span class="octicon octicon-link"></span></a>1. The Challenge</h3>

<p>This is the offical page for the COSC343 first AI project for Nick Dowse and Andrew Ashton. The task was to program lego mindstorm robots in NXC to complete a course as shown below. First the robot had to start, turn 90 degrees, then travel forward over to a black tile, then turn and travel over 14 black tiles, interspersed with white tiles. It then had to turn again and travel over a distance of 7 large grey tiles, before stopping on the finish line.</p>

<p><img src="https://photos-4.dropbox.com/t/1/AACQ2nmcEmcS4PBXVxaxqdMoNz0qOJEMSzCr6S7tbRrgow/12/8148845/png/1024x768/3/1413324000/0/2/Screenshot%202014-10-14%2021.42.27.png/xsJee45eprOsqgFlrd25ZvQ4vIwU4afbW_Eds9OU7nU" alt="Assignment Task"></p>

<p>The second part of the assignment was to write a report about the challenges involved, the processes used, and what you learnt (posted at the bottom of the page).</p>

<h3>
<a name="2-the-code" class="anchor" href="#2-the-code"><span class="octicon octicon-link"></span></a>2. The Code</h3>

<p>The code was broken up into five main parts. These five parts direct the robot around the course. Apart from the preliminary stage to calibrate the sensors each part simply utilises four methods of our methods and some basic movement methods in the NXC language, to move around the course. The major challenge was keeping the robot going in a straight line, and moving in the right direction. The motors powering the wheels had various amounts of power each depending on the battery level, and so you couldn't rely on telling the robot to simply move in a straight line to make the robot move in a straight line.</p>

<h4>
<a name="calibrating-sensors" class="anchor" href="#calibrating-sensors"><span class="octicon octicon-link"></span></a>Calibrating Sensors:</h4>

<p>The first part calibrates the light sensor to recognise the correct colour value for black and the correct colour value for white. The code below loops through until both left and right buttons (<code>Sensor(IN_3)</code> and <code>Sensor(IN_2)</code>) have been clicked, capturing the light value at the time they were clicked as black and white respectively. Once the light values have been calibrated the screen prints out the average value, and we are ready to start.</p>

<pre><code>task calibrate_sensors(){
  int hasBeenCalibrated = 0;
  while (hasBeenCalibrated &lt; 2){
    if (Sensor(IN_3) &amp;&amp; hasBeenCalibrated == 0){
      black = Sensor(IN_1);
      hasBeenCalibrated = 1;
      ClearScreen();
      TextOut(0, 32, "B " + NumToStr(black));
    }
    if (Sensor(IN_2) &amp;&amp; hasBeenCalibrated == 1){
      white = Sensor(IN_1);
      hasBeenCalibrated = 2;
      ClearScreen();
      TextOut(0, 32, "W " + NumToStr(white));
      Wait(2000);
    }
    if (hasBeenCalibrated == 2){
      average = (black + white) / 2;
      ClearScreen();
      TextOut(0, 32, "A " + NumToStr(average));
    }
  }
}
</code></pre>

<h4>
<a name="moving-forward" class="anchor" href="#moving-forward"><span class="octicon octicon-link"></span></a>Moving Forward:</h4>

<p>Plain simple NXC code to move the robot forward.</p>

<pre><code>ClearScreen();
TextOut(0, 32, "Moving forward.");
RotateMotorEx(OUT_BC, 75, 475, 0, true, true);
Off(OUT_BC);
</code></pre>

<h4>
<a name="realigning-on-a-black-tile" class="anchor" href="#realigning-on-a-black-tile"><span class="octicon octicon-link"></span></a>Realigning on a black tile</h4>

<p>Between every black tile was a white tile, so whenever the robot crossed a white tile and reached a black tile we would realign the robot to make sure it was facing in the right direction to continue along a straight line.</p>

<pre><code>sub search(int divisor){
  Off(OUT_BC);
  long degreeRight = move_right();
  long degreeLeft = move_left();
  RotateMotor(RIGHT_MOTOR, -40, degreeLeft + ((degreeRight - degreeLeft)/divisor));
  nextTileIsBlack = false;
  nextTileIsWhite = true;
  isOnBlack = true;
}
</code></pre>

<p>The robot would first move forward onto the black square, and then look right until it found white. It records the degrees it turns, before turning back to the left until it hits white. If the difference was small, we would barely adjust the robots bearings. If the difference was large we would adjust its direction by a larger amount.</p>

<pre><code>long move_right(){
  long degreeRight = MotorRotationCount(LEFT_MOTOR);
  until (Sensor(IN_1) &gt;= (white - 10)){ // until it hits white turn right
    OnFwd(LEFT_MOTOR, 40);
  }
  Off(OUT_BC);
  degreeRight = MotorRotationCount(LEFT_MOTOR) - degreeRight;

  if (degreeRight &lt; 60 ){ // Correction if degrees turned is small.
    degreeRight+= 25;
  } else if (degreeRight &lt; 120){
    degreeRight+= 10;
  }
  RotateMotor(LEFT_MOTOR, -40, degreeRight);
  return degreeRight;
}
</code></pre>

<h4>
<a name="crossing-the-squares" class="anchor" href="#crossing-the-squares"><span class="octicon octicon-link"></span></a>Crossing the squares</h4>

<p>The final functional (rather than organisational) part of our code was a monstrosity that used a lot of variables for state, in order to keep a track of which colour the robot was currently on, and which colour tile was coming up.</p>

<pre><code>sub cross_squares(int numberToCross, int divisor){
  ClearScreen();
  TextOut(0, 32, "Crossing Squares");

  bool isFinished = false;
  int squaresCrossed = 0;

  nextTileIsBlack = false;
  nextTileIsWhite = true;
  isOnBlack = true;

  OnFwdSync(OUT_BC, 75, 0);
  while (!isFinished){

    // If the robot is just reaching a white tile, play tone and set isBlack to false
    if (Sensor(IN_1) &gt; average &amp;&amp; nextTileIsWhite){
      nextTileIsBlack = true;
      nextTileIsWhite = false;
      isOnBlack = false;
      ClearScreen();
      TextOut(0, 32, "Crossed: " + NumToStr(squaresCrossed));
    }

      // If hitting new black square stop, search and readjust, then increment the number of squares crossed.
    if ((squaresCrossed &lt; numberToCross) &amp;&amp; (Sensor(IN_1) &lt; average) &amp;&amp; nextTileIsBlack){
      ClearScreen();
      TextOut(0, 32, "Rotate + Search!");
      RotateMotorEx(OUT_BC, 75, 50, 0, true, true);
      search(divisor);
      squaresCrossed++;
    }

      // if on black square play tone
    if ((squaresCrossed &lt; numberToCross) &amp;&amp; Sensor(IN_1) &lt; average){
      ClearScreen();
      TextOut(0, 32, "On Black");
      // If travelling the small squares move forward until next black square is reached.
      if (divisor == 5){
        ClearScreen();
        TextOut(0, 32, "On small black");
        OnFwdSync(OUT_BC, 75, 0);
        PlayTone(100, 52);
        nextTileIsWhite = true;
      } else {
        // If travelling big squares move forward 800 motor rotations
        // This avoids the problem of picking up the small black flecks in the grey squares
        Off(OUT_BC);
        ClearScreen();
        TextOut(0, 32, "On big black");
        RotateMotorEx(OUT_BC, 75, 790, 0, true, true);
        Off(OUT_BC);
        nextTileIsWhite = false;
        nextTileIsBlack = true;
      }
    }

    // Counting the squares crossed
    ClearScreen();
    TextOut(0, 32, "S " + NumToStr(squaresCrossed) + " N " + NumToStr(numberToCross));

    // If the robot has crossed the number of squares print "Finished Crossing" and return.
    if (squaresCrossed == numberToCross &amp;&amp; nextTileIsWhite){
      isFinished = true;
      ClearScreen();
      TextOut(0, 32, "Finished Crossing");
      return;
    }
  }
}
</code></pre>

<h3>
<a name="part-3-the-results" class="anchor" href="#part-3-the-results"><span class="octicon octicon-link"></span></a>Part 3: The Results</h3>

<p>On the day we had been testing the robot and things were going well. However, disaster struck on the first marked attempt as the light had shifted and the robot got confused between the black and white calibration. It almost immediately veered off course. </p>

<p>We tried again, watching on with bated breath as our robot navigated one section of the course after another, before ending up perfectly centred on the black finishing square. All in all, a great experience, and we only ended up losing marks on the code.</p>

<p>Here's our robot (and Andrew) in action!</p>

<p><img src="https://photos-6.dropbox.com/t/1/AADdKIc1ekZvaZGo-lEMY1Mlj0gHn8ZHe_sDseHQNbh3qg/12/8148845/png/1024x768/3/1413324000/0/2/Screenshot%202014-10-14%2022.42.51.png/yniNGrAjG5xyX5njLIpNxkENPQ0Qxivel60VMLk8MB8" alt="Our robot in action"></p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/nickdowse">nickdowse</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>

  </body>
</html>
