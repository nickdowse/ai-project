<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Ai-project by nickdowse</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Ai-project</h1>
        <p>This is the offical page for the COSC343 first AI project for Nick Dowse and Andrew Ashton. </p>

        <p class="view"><a href="https://github.com/nickdowse/ai-project">View the Project on GitHub <small>nickdowse/ai-project</small></a></p>


        <ul>
          <li><a href="https://github.com/nickdowse/ai-project/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/nickdowse/ai-project/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/nickdowse/ai-project">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h3>
<a name="1-the-challenge" class="anchor" href="#1-the-challenge"><span class="octicon octicon-link"></span></a>1. The Challenge</h3>

<p>The first part of the assignment was to program lego mindstorm robots in NXC to complete a course as shown below. The robot had to start, turn 90 degrees, travel forward over to a black tile, then turn and travel over 14 black tiles interspersed with white tiles. It then had to turn again and travel over a distance of 7 large grey tiles, before stopping on the finish line.</p>

<p><img src="https://photos-4.dropbox.com/t/1/AACQ2nmcEmcS4PBXVxaxqdMoNz0qOJEMSzCr6S7tbRrgow/12/8148845/png/1024x768/3/1413324000/0/2/Screenshot%202014-10-14%2021.42.27.png/xsJee45eprOsqgFlrd25ZvQ4vIwU4afbW_Eds9OU7nU" alt="Assignment Task"></p>

<p>The second part of the assignment was to write a report about the challenges involved, the processes used, and what you learnt, but we'll only go over the code here.</p>

<h3>
<a name="2-the-code" class="anchor" href="#2-the-code"><span class="octicon octicon-link"></span></a>2. The Code</h3>

<p>The code was broken up into five main parts. These five parts direct the robot around the course. Apart from the preliminary stage to calibrate the light sensors each part simply utilises four methods that we wrote, and some basic movement methods in the NXC language in order to move around the course. I'll cover the calibration, moving forward, and the four major functions we wrote to control the robot here.</p>

<p>The major challenge we encountered was keeping the robot going in a straight line and moving in the right direction. The motors powering the wheels had various amounts of power each depending on the battery level, and so you couldn't rely on the robot moving in a straight line when it was directed to.</p>

<h4>
<a name="calibrating-the-light-sensor" class="anchor" href="#calibrating-the-light-sensor"><span class="octicon octicon-link"></span></a>Calibrating the light Sensor:</h4>

<p>We used the light sensor to determine whether the robot was on a black or white tile, and we manually calibrated the sensor before the robot began its run. The first part of calibrating the light sensors was to recognise the correct colour value for black and the correct colour value for white. The code below runs in a loop until both left and right buttons (<code>Sensor(IN_3)</code> and <code>Sensor(IN_2)</code>) have been clicked. When one is clicked the light value is detected from the third sensor (<code>Sensor(IN_1)</code>) and stored in the black and white variables respectively. Once the light values have been calibrated the screen prints out the average value, and we are ready to start.</p>

<pre><code>task calibrate_sensors(){
  int hasBeenCalibrated = 0;
  while (hasBeenCalibrated &lt; 2){
    if (Sensor(IN_3) &amp;&amp; hasBeenCalibrated == 0){
      black = Sensor(IN_1);
      hasBeenCalibrated = 1;
      ClearScreen();
      TextOut(0, 32, "B " + NumToStr(black));
    }
    if (Sensor(IN_2) &amp;&amp; hasBeenCalibrated == 1){
      white = Sensor(IN_1);
      hasBeenCalibrated = 2;
      ClearScreen();
      TextOut(0, 32, "W " + NumToStr(white));
      Wait(2000);
    }
    if (hasBeenCalibrated == 2){
      average = (black + white) / 2;
      ClearScreen();
      TextOut(0, 32, "A " + NumToStr(average));
    }
  }
}
</code></pre>

<h4>
<a name="moving-forward" class="anchor" href="#moving-forward"><span class="octicon octicon-link"></span></a>Moving Forward:</h4>

<p>Plain and simple NXC code to move the robot forward.</p>

<pre><code>ClearScreen();
TextOut(0, 32, "Moving forward.");
RotateMotorEx(OUT_BC, 75, 475, 0, true, true);
Off(OUT_BC);
</code></pre>

<h4>
<a name="realigning-on-a-black-tile" class="anchor" href="#realigning-on-a-black-tile"><span class="octicon octicon-link"></span></a>Realigning on a black tile</h4>

<p>This code was used heavily when crossing 14 black tiles. Between every black tile was a white tile, so whenever the robot crossed a white tile and reached a black tile we would use this code to realign the robot to face in the direction of the next black tile.</p>

<pre><code>sub search(int divisor){
  Off(OUT_BC);
  long degreeRight = move_right();
  long degreeLeft = move_left();
  RotateMotor(RIGHT_MOTOR, -40, degreeLeft + ((degreeRight - degreeLeft)/divisor));
  nextTileIsBlack = false;
  nextTileIsWhite = true;
  isOnBlack = true;
}
</code></pre>

<p>The robot would start by moving forward onto the black square, and then look right until it found white. It records the number degrees it turns based on how far the wheels spin, before turning back to the left until it hits white. If the difference was small, we would barely adjust the robots bearings. If the difference was large we would adjust its direction by a larger amount.</p>

<pre><code>long move_right(){
  long degreeRight = MotorRotationCount(LEFT_MOTOR);
  until (Sensor(IN_1) &gt;= (white - 10)){ // until it hits white turn right
    OnFwd(LEFT_MOTOR, 40);
  }
  Off(OUT_BC);
  degreeRight = MotorRotationCount(LEFT_MOTOR) - degreeRight;

  if (degreeRight &lt; 60 ){ // Correction if degrees turned is small.
    degreeRight+= 25;
  } else if (degreeRight &lt; 120){
    degreeRight+= 10;
  }
  RotateMotor(LEFT_MOTOR, -40, degreeRight);
  return degreeRight;
}
</code></pre>

<h4>
<a name="crossing-the-squares" class="anchor" href="#crossing-the-squares"><span class="octicon octicon-link"></span></a>Crossing the squares</h4>

<p>This was the core of our code, and the final function that I'll talk about here. It is a monstrosity that used a lot of variables for state, in order to keep a track of which colour the robot was currently on, and which colour tile was coming up. The divisor was the a factor of the distance between the squares the robot had to cross. The higher it is the lower the correction of the robot when searching and realigning. This was done to prevent overcorrection.</p>

<pre><code>sub cross_squares(int numberToCross, int divisor){
  ClearScreen();
  TextOut(0, 32, "Crossing Squares");

  bool isFinished = false;
  int squaresCrossed = 0;

  nextTileIsBlack = false;
  nextTileIsWhite = true;
  isOnBlack = true;

  OnFwdSync(OUT_BC, 75, 0);
  while (!isFinished){

    // If the robot is just reaching a white tile, play tone and set isBlack to false
    if (Sensor(IN_1) &gt; average &amp;&amp; nextTileIsWhite){
      nextTileIsBlack = true;
      nextTileIsWhite = false;
      isOnBlack = false;
      ClearScreen();
      TextOut(0, 32, "Crossed: " + NumToStr(squaresCrossed));
    }

      // If hitting new black square stop, search and readjust, then increment the number of squares crossed.
    if ((squaresCrossed &lt; numberToCross) &amp;&amp; (Sensor(IN_1) &lt; average) &amp;&amp; nextTileIsBlack){
      ClearScreen();
      TextOut(0, 32, "Rotate + Search!");
      RotateMotorEx(OUT_BC, 75, 50, 0, true, true);
      search(divisor);
      squaresCrossed++;
    }

      // if on black square play tone
    if ((squaresCrossed &lt; numberToCross) &amp;&amp; Sensor(IN_1) &lt; average){
      ClearScreen();
      TextOut(0, 32, "On Black");
      // If travelling the small squares move forward until next black square is reached.
      if (divisor == 5){
        ClearScreen();
        TextOut(0, 32, "On small black");
        OnFwdSync(OUT_BC, 75, 0);
        PlayTone(100, 52);
        nextTileIsWhite = true;
      } else {
        // If travelling big squares move forward 800 motor rotations
        // This avoids the problem of picking up the small black flecks in the grey squares
        Off(OUT_BC);
        ClearScreen();
        TextOut(0, 32, "On big black");
        RotateMotorEx(OUT_BC, 75, 790, 0, true, true);
        Off(OUT_BC);
        nextTileIsWhite = false;
        nextTileIsBlack = true;
      }
    }

    // Counting the squares crossed
    ClearScreen();
    TextOut(0, 32, "S " + NumToStr(squaresCrossed) + " N " + NumToStr(numberToCross));

    // If the robot has crossed the number of squares print "Finished Crossing" and return.
    if (squaresCrossed == numberToCross &amp;&amp; nextTileIsWhite){
      isFinished = true;
      ClearScreen();
      TextOut(0, 32, "Finished Crossing");
      return;
    }
  }
}
</code></pre>

<h3>
<a name="part-3-the-results" class="anchor" href="#part-3-the-results"><span class="octicon octicon-link"></span></a>Part 3: The Results</h3>

<p>On the day we had been testing the robot and things were going well. However, disaster struck on the first marked attempt as the light had shifted and the robot got confused between the black and white calibration. It almost immediately veered off course. </p>

<p>We tried again, watching on with bated breath as our robot navigated one section of the course after another, before ending up perfectly centred on the black finishing square. All in all, a great experience, and we only ended up losing marks on the code.</p>

<p>Here's our robot (and Andrew) in action!</p>

<p><img src="https://photos-6.dropbox.com/t/1/AADdKIc1ekZvaZGo-lEMY1Mlj0gHn8ZHe_sDseHQNbh3qg/12/8148845/png/1024x768/3/1413324000/0/2/Screenshot%202014-10-14%2022.42.51.png/yniNGrAjG5xyX5njLIpNxkENPQ0Qxivel60VMLk8MB8" alt="Our robot in action"></p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/nickdowse">nickdowse</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>