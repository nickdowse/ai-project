{"name":"Ai-project","tagline":"This is the offical page for the COSC343 first AI project for Nick Dowse and Andrew Ashton. ","body":"### 1. The Challenge\r\nThe first part of the assignment was to program lego mindstorm robots in NXC to complete a course as shown below. The robot had to start, turn 90 degrees, travel forward over to a black tile, then turn and travel over 14 black tiles interspersed with white tiles. It then had to turn again and travel over a distance of 7 large grey tiles, before stopping on the finish line.\r\n\r\n![Assignment Task]\r\n(https://photos-4.dropbox.com/t/1/AACQ2nmcEmcS4PBXVxaxqdMoNz0qOJEMSzCr6S7tbRrgow/12/8148845/png/1024x768/3/1413324000/0/2/Screenshot%202014-10-14%2021.42.27.png/xsJee45eprOsqgFlrd25ZvQ4vIwU4afbW_Eds9OU7nU)\r\n\r\nThe second part of the assignment was to write a report about the challenges involved, the processes used, and what you learnt (posted at the bottom of the page).\r\n\r\n### 2. The Code\r\n\r\nThe code was broken up into five main parts. These five parts direct the robot around the course. Apart from the preliminary stage to calibrate the light sensors each part simply utilises four methods that we wrote, and some basic movement methods in the NXC language in order to move around the course. I'll cover the calibration, moving forward, and the four major functions we wrote to control the robot here.\r\n\r\nThe major challenge we encountered was keeping the robot going in a straight line and moving in the right direction. The motors powering the wheels had various amounts of power each depending on the battery level, and so you couldn't rely on the robot moving in a straight line when it was directed to.\r\n\r\n#### Calibrating the light Sensor:\r\n\r\nWe used the light sensor to determine whether the robot was on a black or white tile, and we manually calibrated the sensor before the robot began its run. The first part of calibrating the light sensors was to recognise the correct colour value for black and the correct colour value for white. The code below runs in a loop until both left and right buttons (`Sensor(IN_3)` and `Sensor(IN_2)`) have been clicked. When one is clicked the light value is detected from the third sensor (`Sensor(IN_1)`) and stored in the black and white variables respectively. Once the light values have been calibrated the screen prints out the average value, and we are ready to start.\r\n\r\n```\r\ntask calibrate_sensors(){\r\n  int hasBeenCalibrated = 0;\r\n  while (hasBeenCalibrated < 2){\r\n    if (Sensor(IN_3) && hasBeenCalibrated == 0){\r\n      black = Sensor(IN_1);\r\n      hasBeenCalibrated = 1;\r\n      ClearScreen();\r\n      TextOut(0, 32, \"B \" + NumToStr(black));\r\n    }\r\n    if (Sensor(IN_2) && hasBeenCalibrated == 1){\r\n      white = Sensor(IN_1);\r\n      hasBeenCalibrated = 2;\r\n      ClearScreen();\r\n      TextOut(0, 32, \"W \" + NumToStr(white));\r\n      Wait(2000);\r\n    }\r\n    if (hasBeenCalibrated == 2){\r\n      average = (black + white) / 2;\r\n      ClearScreen();\r\n      TextOut(0, 32, \"A \" + NumToStr(average));\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### Moving Forward:\r\n\r\nPlain and simple NXC code to move the robot forward.\r\n\r\n```\r\nClearScreen();\r\nTextOut(0, 32, \"Moving forward.\");\r\nRotateMotorEx(OUT_BC, 75, 475, 0, true, true);\r\nOff(OUT_BC);\r\n```\r\n\r\n#### Realigning on a black tile\r\n\r\nThis code was used heavily when crossing 14 black tiles. Between every black tile was a white tile, so whenever the robot crossed a white tile and reached a black tile we would use this code to realign the robot to face in the direction of the next black tile.\r\n\r\n```\r\nsub search(int divisor){\r\n  Off(OUT_BC);\r\n  long degreeRight = move_right();\r\n  long degreeLeft = move_left();\r\n  RotateMotor(RIGHT_MOTOR, -40, degreeLeft + ((degreeRight - degreeLeft)/divisor));\r\n  nextTileIsBlack = false;\r\n  nextTileIsWhite = true;\r\n  isOnBlack = true;\r\n}\r\n```\r\n\r\nThe robot would start by moving forward onto the black square, and then look right until it found white. It records the number degrees it turns based on how far the wheels spin, before turning back to the left until it hits white. If the difference was small, we would barely adjust the robots bearings. If the difference was large we would adjust its direction by a larger amount.\r\n\r\n```\r\nlong move_right(){\r\n  long degreeRight = MotorRotationCount(LEFT_MOTOR);\r\n  until (Sensor(IN_1) >= (white - 10)){ // until it hits white turn right\r\n    OnFwd(LEFT_MOTOR, 40);\r\n  }\r\n  Off(OUT_BC);\r\n  degreeRight = MotorRotationCount(LEFT_MOTOR) - degreeRight;\r\n\r\n  if (degreeRight < 60 ){ // Correction if degrees turned is small.\r\n    degreeRight+= 25;\r\n  } else if (degreeRight < 120){\r\n    degreeRight+= 10;\r\n  }\r\n  RotateMotor(LEFT_MOTOR, -40, degreeRight);\r\n  return degreeRight;\r\n}\r\n```\r\n\r\n#### Crossing the squares\r\n\r\nThis was the core of our code, and the final function that I'll talk about here. It is a monstrosity that used a lot of variables for state, in order to keep a track of which colour the robot was currently on, and which colour tile was coming up. The divisor was the a factor of the distance between the squares the robot had to cross. The higher it is the lower the correction of the robot when searching and realigning. This was done to prevent overcorrection.\r\n\r\n```\r\nsub cross_squares(int numberToCross, int divisor){\r\n  ClearScreen();\r\n  TextOut(0, 32, \"Crossing Squares\");\r\n\r\n  bool isFinished = false;\r\n  int squaresCrossed = 0;\r\n\r\n  nextTileIsBlack = false;\r\n  nextTileIsWhite = true;\r\n  isOnBlack = true;\r\n\r\n  OnFwdSync(OUT_BC, 75, 0);\r\n  while (!isFinished){\r\n\r\n    // If the robot is just reaching a white tile, play tone and set isBlack to false\r\n    if (Sensor(IN_1) > average && nextTileIsWhite){\r\n      nextTileIsBlack = true;\r\n      nextTileIsWhite = false;\r\n      isOnBlack = false;\r\n      ClearScreen();\r\n      TextOut(0, 32, \"Crossed: \" + NumToStr(squaresCrossed));\r\n    }\r\n\r\n      // If hitting new black square stop, search and readjust, then increment the number of squares crossed.\r\n    if ((squaresCrossed < numberToCross) && (Sensor(IN_1) < average) && nextTileIsBlack){\r\n      ClearScreen();\r\n      TextOut(0, 32, \"Rotate + Search!\");\r\n      RotateMotorEx(OUT_BC, 75, 50, 0, true, true);\r\n      search(divisor);\r\n      squaresCrossed++;\r\n    }\r\n\r\n      // if on black square play tone\r\n    if ((squaresCrossed < numberToCross) && Sensor(IN_1) < average){\r\n      ClearScreen();\r\n      TextOut(0, 32, \"On Black\");\r\n      // If travelling the small squares move forward until next black square is reached.\r\n      if (divisor == 5){\r\n        ClearScreen();\r\n        TextOut(0, 32, \"On small black\");\r\n        OnFwdSync(OUT_BC, 75, 0);\r\n        PlayTone(100, 52);\r\n        nextTileIsWhite = true;\r\n      } else {\r\n        // If travelling big squares move forward 800 motor rotations\r\n        // This avoids the problem of picking up the small black flecks in the grey squares\r\n        Off(OUT_BC);\r\n        ClearScreen();\r\n        TextOut(0, 32, \"On big black\");\r\n        RotateMotorEx(OUT_BC, 75, 790, 0, true, true);\r\n        Off(OUT_BC);\r\n        nextTileIsWhite = false;\r\n        nextTileIsBlack = true;\r\n      }\r\n    }\r\n\r\n    // Counting the squares crossed\r\n    ClearScreen();\r\n    TextOut(0, 32, \"S \" + NumToStr(squaresCrossed) + \" N \" + NumToStr(numberToCross));\r\n\r\n    // If the robot has crossed the number of squares print \"Finished Crossing\" and return.\r\n    if (squaresCrossed == numberToCross && nextTileIsWhite){\r\n      isFinished = true;\r\n      ClearScreen();\r\n      TextOut(0, 32, \"Finished Crossing\");\r\n      return;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Part 3: The Results\r\n\r\nOn the day we had been testing the robot and things were going well. However, disaster struck on the first marked attempt as the light had shifted and the robot got confused between the black and white calibration. It almost immediately veered off course. \r\n\r\nWe tried again, watching on with bated breath as our robot navigated one section of the course after another, before ending up perfectly centred on the black finishing square. All in all, a great experience, and we only ended up losing marks on the code.\r\n\r\nHere's our robot (and Andrew) in action!\r\n\r\n![Our robot in action]\r\n(https://photos-6.dropbox.com/t/1/AADdKIc1ekZvaZGo-lEMY1Mlj0gHn8ZHe_sDseHQNbh3qg/12/8148845/png/1024x768/3/1413324000/0/2/Screenshot%202014-10-14%2022.42.51.png/yniNGrAjG5xyX5njLIpNxkENPQ0Qxivel60VMLk8MB8)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}